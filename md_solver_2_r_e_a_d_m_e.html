<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>svMultiPhysics: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">svMultiPhysics
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">README</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>svFSI_cinterface </h1>
<p>This directory contains the C++ solver implementation. The C++ code attempts to replicate the data structures and flow of control of the Fortran implementation.</p>
<p>The <code><a class="el" href="class_simulation.html">Simulation</a></code> class stores solver parameters and data, and has methods to read solver parameters from a XML file and create mesh data (e.g. nodes and element connectivity) from VTK .vtu and .vtp files. A <code><a class="el" href="class_simulation.html">Simulation</a></code> object can be created and stored in the the Fortran <code>CMMOD</code> module. It can then be called to replicated the Fortran flow of control and compare data created by C++ and Fortran.</p>
<h1>Reading the solver parameter input XML file </h1>
<p>The <code><a class="el" href="class_parameters.html" title="The Parameters class stores parameter values read in from a solver input file.">Parameters</a></code> class is used to read and store solver parameters from an XML file. The XML file organization and parameter names replicate the old input text file except that parameter names have spaces replaced by underscores.</p>
<h1>Calling C++ from Fortran </h1>
<p>The <code>simulation_wrap.h,.cpp</code> files provide an interface used to call C++ functions from Fortran. Data created in the C++ code can be returned to the Fortran code for comparison.</p>
<p>The following interface functions are defiined</p>
<ul>
<li>create_simulation() - Creates and returns a <a class="el" href="class_simulation.html">Simulation</a> object.</li>
<li>get_mesh_data() - Returns mesh data for a specific mesh name.</li>
<li>read_files() - Reads in the solver parameter input XML file and creates all mesh data.</li>
</ul>
<h1>C++ organizatiion to replicate Fortran </h1>
<p>Most of the Fortran code is replicated in C++ using the same file and subroutine names converted to lower case with underscores. For example</p>
<div class="fragment"><div class="line">================================================================================================</div>
<div class="line">             Fortran                       |                      C++ </div>
<div class="line">================================================================================================</div>
<div class="line">        SUBROUTINE READFILES               |                  read_files()</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="line">        SUBROUTINE READMSH                 |                  read_msh()</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="line">            LOADMSH.f                      |                  load_msh.cpp</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="line">            VTKXML.f                       |                  vtk_xml.cpp</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
</div><!-- fragment --><p>All Fortan subroutines located in a particular file will typically have a C++ implementation in a similarly named file.</p>
<p>C++ functions are defined within a <code>namespace</code> defined for each Fortran file. For example, the functioins in <code>load_msh.cpp</code> are defined within the <code>load_msh</code> <code>namespace</code>. Some <code>namespaces</code> are named with a <code>_ns</code> suffix to prevent conflicts with function names (e.g. <code><a class="el" href="namespaceread__files__ns.html" title="Define some types used to pass data to functions.">read_files_ns</a></code>).</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Fortran Modules</h1>
<p>C++ classes are used to implement Fortran modules. Fortran variable names are retained to prevent (or maintain) confusion. There are no global variables. Modules are accessed from a <code><a class="el" href="class_simulation.html">Simulation</a></code> object.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
CmMod</h2>
<p>The <code><a class="el" href="class_cm_mod.html" title="The CmMod class duplicates the data structures in the Fortran CMMOD module defined in COMU....">CmMod</a></code> class implements the <code>CMMOD</code> module defined in <code>COMU.f</code>. This is used for MPI communication.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
ComMod</h2>
<p>The <code><a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a></code> class implments the <code>COMOD</code> module defiined in <code>MOD.f</code>.</p>
<p>All solver data is stored in the <code><a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a></code> class using the same names used in the <code>COMOD</code> module.</p>
<h1 id="flow_of_control">Flow of control </h1>
<p>The following outlines the code flow of control for simulations.</p>
<ul>
<li>PROGRAM MAIN<ul>
<li>sim_interface = simulation()</li>
<li>call sim_interface % read_files(in_file_name)<ul>
<li>call read_files_c(this % Simulation_object, c_file_name)<ul>
<li>&lt;i&gt;read_files_ns::&lt;/i&gt;&lt;b&gt;read_files(simulation, std::string(file_name))&lt;/b&gt;<ul>
<li>simulation-&gt;&lt;b&gt;read_parameters()&lt;/b&gt; - Read solver parameter XML file</li>
<li>simulation-&gt;&lt;b&gt;set_module_parameters()&lt;/b&gt; - Set <a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a> module varliables</li>
<li>&lt;i&gt;read_msh_ns::&lt;/i&gt;&lt;b&gt;read_msh(simulation)&lt;/b&gt; - Read all mesh and BCs data<ul>
<li>&lt;i&gt;load_msh::&lt;/i&gt;&lt;b&gt;read_sv(param, mesh)&lt;/b&gt; - Read mesh nodal coordinates and element connectivity<ul>
<li>&lt;i&gt;vtk_xml::&lt;/i&gt;&lt;b&gt;read_vtu(mesh_path, mesh)&lt;/b&gt; - Read a mesh from a SimVascular .vtu file<ul>
<li>&lt;i&gt;vtk_xml_parser::&lt;/i&gt;&lt;b&gt;load_vtu(file_name, mesh)&lt;/b&gt; - Read a mesh from a .vtu file and store its data into mesh</li>
</ul>
</li>
<li>&lt;i&gt;nn::&lt;/i&gt;&lt;b&gt;select_ele(simulation, mesh)&lt;/b&gt; - Set mesh variables for the input element type<ul>
<li>&lt;b&gt;set_3d_element_props\[mesh.eNoN\](mesh)&lt;/b&gt; - Set element properties based on the number of element nodes</li>
<li>&lt;b&gt;get_gip(simulation, mesh)&lt;/b&gt; - Set mesh w and xi arrays used for Gauss integration</li>
<li>&lt;b&gt;get_gnn(simulation, g, mesh)&lt;/b&gt; - Create mesh N and Nx shape function arrays for each Gaus point g</li>
<li>&lt;b&gt;get_nn_bnds(simulation, mesh)&lt;/b&gt; - Create bounds on Gauss integration points and shape functions</li>
</ul>
</li>
<li>&lt;i&gt;read_msh_ns::&lt;/i&gt;&lt;b&gt;check_ien(simulation, mesh)&lt;/b&gt; - Check/change the mesh connectivity and node ordering<ul>
<li>&lt;b&gt;check_element_conn\[eType\](mesh)&lt;/b&gt;</li>
</ul>
</li>
<li>&lt;i&gt;vtk_xml::&lt;/i&gt;&lt;b&gt;read_vtp(face_path, face)&lt;/b&gt; - Read a face nodal coordinates and element connectivity from a .vtp file<ul>
<li>&lt;i&gt;vtk_xml_parser::&lt;/i&gt;&lt;b&gt;load_vtp(file_name, face)&lt;/b&gt; - Store data read from a .vtp file into a <a class="el" href="classface_type.html" title="The face type containing mesh at boundary.">faceType</a> object</li>
</ul>
</li>
<li>&lt;i&gt;nn::&lt;/i&gt;&lt;b&gt;select_eleb(simulation, mesh, face)&lt;/b&gt; - Set face properties for the input element type<ul>
<li>&lt;b&gt;set_face_element_props\[face.eNoN\](insd, face)&lt;/b&gt;</li>
<li>&lt;b&gt;get_gip(simulation, face)&lt;/b&gt;</li>
<li>&lt;b&gt;get_gnn(simulation, g, face)&lt;/b&gt;</li>
</ul>
</li>
</ul>
</li>
<li>&lt;b&gt;set_projector(simulation, avNds)&lt;/b&gt; - Process projection faces<ul>
<li>&lt;b&gt;all_fun::find_face(com_mod.msh, ctmpi, iM, iFa)&lt;/b&gt; - Process projection faces</li>
<li>&lt;b&gt;match_faces(com_mod, face1, face2, tol, lPrj)&lt;/b&gt; - Process projection faces<ul>
<li>&lt;b&gt;find_blk(nsd, nBkd, nFlt, xMin, dx, coord)&lt;/b&gt; - Compute the block ID for the given coordinate</li>
</ul>
</li>
</ul>
</li>
<li>&lt;b&gt;read_fib_nff(simulation, com_mod.msh\[iM\], cTmp, &quot;FIB_DIR&quot;, i)&lt;/b&gt; - Read fiber orientation<ul>
<li>&lt;b&gt;vtk_xml_parser::load_fiber_direction_vtu(fName, kwrd, idx, simulation-&gt;com_mod.nsd, mesh)&lt;/b&gt; - Read fiber orientation from vtu</li>
</ul>
</li>
<li>&lt;b&gt;vtk_xml::read_vtu_pdata(cTmp, &quot;Stress&quot;, com_mod.nsd, com_mod.nsymd, 0, com_mod.msh\[iM\])&lt;/b&gt; - Read prestress data</li>
<li>&lt;b&gt;load_var_ini(simulation, com_mod)&lt;/b&gt; - Set initial mesh pressure, velocity or displacement from a file</li>
<li><b>Read contact model parameters (not implmented, no tests)</b></li>
</ul>
</li>
<li>&lt;b&gt;read_eq(simulation, simulation, eq_params, eq)&lt;/b&gt; - Iterate to read equations<ul>
<li>&lt;b&gt;set_equation_properties(simulation, eq_params, lEq, propL, outPuts, nDOP)&lt;/b&gt; - Set equation properties<ul>
<li>&lt;b&gt;set_equation_props[eq_type](simulation, eq_params, lEq, propL, outPuts, nDOP)&lt;/b&gt; - Set equation properties (function map)</li>
</ul>
</li>
<li>&lt;b&gt;read_outputs(simulation, eq_params, lEq, nDOP, outPuts)&lt;/b&gt; - Set output parameters</li>
<li>&lt;b&gt;read_bc(simulation, Set output parameters)&lt;/b&gt; - Iterate to read boundary conditions<ul>
<li>&lt;b&gt;read_trac_bcff(com_mod, lBc.gm, com_mod.msh\[iM\].fa\[iFa\], file_name)&lt;/b&gt; - Read traction data</li>
<li>&lt;b&gt;read_temporal_values_file(file_name, lBc)&lt;/b&gt; - Set boundary condition temporal values read in from a file</li>
<li>&lt;b&gt;read_fourier_coeff_values_file(file_name, lBc)&lt;/b&gt; - Set boundary condition Fourier coefficients read in from a file</li>
<li>&lt;b&gt;read_bct(com_mod, lBc.gm, com_mod.msh\[iM\].fa\[iFa\], file_name)&lt;/b&gt; - Reads general velocity data from bct.vtp</li>
<li>&lt;b&gt;read_temporal_and_spatial_values_file(com_mod, com_mod.msh\[iM\], com_mod.msh\[iM\].fa\[iFa\], file_name, lBc)&lt;/b&gt; - Read in a file containing temporal and spatial values</li>
<li>&lt;b&gt;read_spatial_values_file(com_mod, com_mod.msh\[iM\], com_mod.msh\[iM\].fa\[iFa\], file_name, lBc)&lt;/b&gt; - Read in a file containing spatial values</li>
<li>&lt;b&gt;vtk_xml::read_vtp_pdata(cTmp, &quot;Stress&quot;, com_mod.nsd, com_mod.nsymd, data_series, face)&lt;/b&gt; - Read prestress tensor for CMM</li>
<li>&lt;b&gt;vtk_xml::read_vtp_pdata(cTmp, &quot;Displacement&quot;, com_mod.nsd, com_mod.nsd, data_series, face)&lt;/b&gt; - Read displacement for CMM</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>&lt;b&gt;call sim_interface % distribute_data()&lt;/b&gt;<ul>
<li>&lt;b&gt;call distribute_data_c(this % Simulation_object)&lt;/b&gt;<ul>
<li>&lt;b&gt;distribute(Simulation* simulation))&lt;/b&gt; - Partition and distribute data across processors<ul>
<li>&lt;b&gt;cm.bcast(cm_mod, &amp;chnl_mod.pClr)&lt;/b&gt; -</li>
<li>&lt;b&gt;cm.bcast(cm_mod, chnl_mod.appPath)&lt;/b&gt; -</li>
<li>&lt;b&gt;cm.bcast(cm_mod, &amp;com_mod.nMsh)&lt;/b&gt; -</li>
<li>&lt;b&gt;cm.bcast(cm_mod, &amp;com_mod.nsd)&lt;/b&gt; -</li>
<li>&lt;b&gt;cm.bcast(cm_mod, wrk)&lt;/b&gt; -</li>
<li>&lt;i&gt;all_fun::&lt;/i&gt;&lt;b&gt;split_jobs(task_id, nMsh, num_proc, wgt, wrk)&lt;/b&gt; - Spliting "m" jobs between "n" workers</li>
<li>&lt;b&gt;part_msh(simulation, com_mod.msh\[iM\], gmtl, num_proc, iWgt)&lt;/b&gt; - Partition each mesh iM<ul>
<li>&lt;i&gt;nn::&lt;/i&gt;&lt;b&gt;select_ele(simulation, lM)&lt;/b&gt; - Spliting "m" jobs between "n" workers</li>
<li>&lt;b&gt;split_(&amp;nEl, &amp;eNoN, &amp;eNoNb, lM.IEN.data_, &amp;num_proc, lM.eDist.data_, wgt.data_, part.data_)&lt;/b&gt; - Partitioning using ParMetis</li>
</ul>
</li>
<li>&lt;b&gt;part_face(simulation, msh, face, tMs\[iM\].fa\[iFa\], gmtl)&lt;/b&gt; - Partitioning iFa faces for each mesh iM <br  />
<ul>
<li>&lt;i&gt;nn::&lt;/i&gt;&lt;b&gt;select_eleb(simulation, lM, gFa)&lt;/b&gt; - Set face properties for the input element type</li>
</ul>
</li>
<li>&lt;i&gt;all_fun::&lt;/i&gt;&lt;b&gt;local_rv(com_mod, cm_mod, cm, tmpX)&lt;/b&gt; - Send a real vector to all the processors</li>
<li>&lt;b&gt;dist_eq(com_mod, cm_mod, cm, tMs, gmtl, cep_mod, com_mod.eq\[iEq\])&lt;/b&gt; - Distribute equation iEq to processors<ul>
<li>&lt;b&gt;dist_mat_consts(com_mod, cm_mod, cm, dmn.stM)&lt;/b&gt; - Distribute material properties to processors</li>
<li>&lt;b&gt;dist_bc(com_mod, cm_mod, cm, lEq.bc\[iBc\], tMs, gmtl)&lt;/b&gt; - Distribute boundary condition data to processors</li>
<li>&lt;b&gt;dist_visc_model(com_mod, cm_mod, cm, dmn.visc)&lt;/b&gt; - Distribute viscosity model to processors</li>
<li>&lt;b&gt;dist_bf(com_mod, cm_mod, cm, lEq.bf\[iBf\])&lt;/b&gt; - Distribute boundary fource to processors</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>&lt;b&gt;call sim_interface % initialize_solution(timeP)&lt;/b&gt;<ul>
<li>&lt;b&gt;call initialize_solution_c(this % Simulation_object, timeP)&lt;/b&gt;<ul>
<li>&lt;b&gt;initialize_solution(Simulation* simulation)&lt;/b&gt; - Initialize or finalize svFSI variables/structures<ul>
<li>&lt;b&gt;mat_fun::ten_init(nsd)&lt;/b&gt; - Initialize tensor operations</li>
<li>&lt;b&gt;lhsa_ns::lhsa(simulation, nnz)&lt;/b&gt; - Constructing stiffness matrix</li>
<li>&lt;b&gt;fsi_linear_solver::fsils_commu_create(communicator, cm.com())&lt;/b&gt; -</li>
<li>&lt;b&gt;fsi_linear_solver::fsils_lhs_create(com_mod.lhs, communicator, com_mod.gtnNo, com_mod.tnNo, nnz,com_mod.ltg, com_mod.rowPtr, com_mod.colPtr, nFacesLS)&lt;/b&gt; - Initialize FSILS structures</li>
<li>&lt;b&gt;cep_ion::cep_init(simulation)&lt;/b&gt; -<ul>
<li>&lt;b&gt;cep_ion::cep_init_l(CepMod&amp; cep_mod, cepModelType&amp; cep, int nX, int nG, Vector&lt;double&gt;&amp; X, Vector&lt;double&gt;&amp; Xg)&lt;/b&gt; -<ul>
<li>[<b>cep_mod.ap.init(nX, X)</b>]() -</li>
<li>[<b>cep_mod.bo.init(nX, X)</b>]() -</li>
<li>[<b>cep_mod.bfn.init(nX, X)</b>]() -</li>
<li>[<b>cep_mod.ttp.init(cep.imyo, nX, nG, X, Xg)</b>]() -</li>
</ul>
</li>
</ul>
</li>
<li>&lt;b&gt;fs::init_fs_msh(com_mod, mesh)&lt;/b&gt; -</li>
<li>&lt;b&gt;fs::init_fs_face(com_mod, mesh, mesh.fa[iFa])&lt;/b&gt; -</li>
<li>&lt;b&gt;all_fun::integ(com_mod, cm_mod, i, s, 0, 0)&lt;/b&gt; - Calculating the volume of each domain</li>
<li>&lt;b&gt;baf_ini_ns::baf_ini(simulation)&lt;/b&gt; - Preparing faces<ul>
<li>"" "&lt;b&gt;set_bc::rcr_init(com_mod, cm_mod)&lt;/b&gt;"</li>
<li>"" "&lt;b&gt;set_bc::genBC_Integ_X(com_mod, cm_mod, &amp;quot;I&amp;quot;)&lt;/b&gt;"</li>
<li>"" "&lt;b&gt;set_bc::calc_der_cpl_bc(com_mod, cm_mod)&lt;/b&gt;"</li>
<li>&lt;b&gt;fsi_ls_ini(com_mod, cm_mod, bc, com_mod.msh[iM].fa[iFa], lsPtr)&lt;/b&gt;</li>
<li>&lt;b&gt;fsils_bc_create(com_mod.lhs, lsPtr, i, nsd, BcType::BC_TYPE_Dir, gNodes)&lt;/b&gt;</li>
</ul>
</li>
<li>&lt;b&gt;set_bc::set_bc_dir(com_mod, com_mod.Ao, com_mod.Yo, com_mod.Do)&lt;/b&gt; - Preparing BCs<ul>
<li>&lt;b&gt;set_bc::set_bc_dir_l(com_mod, bc, com_mod.msh[iM].fa[iFa], tmpA, tmpY, lDof)&lt;/b&gt;</li>
</ul>
</li>
<li>[<b>txt_ns::txt(simulation, true)</b>]() -</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>&lt;b&gt;call sim_interface % iterate_solution()&lt;/b&gt;<ul>
<li>&lt;b&gt;call interate_solution_c(this % Simulation_object)&lt;/b&gt;<ul>
<li>&lt;b&gt; pic::picp(simulation) &lt;/b&gt; - Predictor<ul>
<li>&lt;b&gt; cep_ion::cep_integ(simulation, iEq, e, Do) &lt;/b&gt;</li>
</ul>
</li>
<li>&lt;b&gt; set_bc::set_bc_dir(com_mod, An, Yn, Dn) &lt;/b&gt; - Apply Dirichlet BCs strongly</li>
<li><b> Inner Loop </b><ul>
<li>&lt;b&gt; set_bc::set_bc_cpl(com_mod, cm_mod) &lt;/b&gt; - If com_mod.cplBC.coupled</li>
<li>&lt;b&gt; set_bc::set_bc_dir(com_mod, An, Yn, Dn) &lt;/b&gt; - If com_mod.cplBC.coupled</li>
<li>&lt;b&gt; pic::pici(simulation, Ag, Yg, Dg) &lt;/b&gt; - Initiator step</li>
<li>&lt;b&gt; ls_ns::ls_alloc(com_mod, eq) &lt;/b&gt;</li>
<li>&lt;b&gt; bf::set_bf(com_mod, Dg) &lt;/b&gt;<ul>
<li>&lt;b&gt; bf::set_bf_l(com_mod, eq.bf[iBf], com_mod.msh[iM], Dg) &lt;/b&gt;<ul>
<li>"" "&lt;b&gt; ifft(com_mod, lBf.bt, f, rtmp) &lt;/b&gt;" - If bfType_ustd</li>
<li>"" "&lt;b&gt; igbc(com_mod, lBf.bm, bfl, xl) &lt;/b&gt;" - If bfType_gen</li>
<li>&lt;b&gt; bf::bf_construct(com_mod, lM, e, eNoN, idof, xl, dl, bfl, ptr) &lt;/b&gt; - For shell follower pressre loads or init pressure for CMM</li>
</ul>
</li>
</ul>
</li>
<li>&lt;b&gt; eq_assem::global_eq_assem(com_mod, com_mod.msh[iM], Ag, Yg, Dg) &lt;/b&gt; - For each mesh iM<ul>
<li>&lt;b&gt; fluid::construct_fluid(com_mod, lM, Ag, Yg) &lt;/b&gt; - If EquationType::phys_fluid<ul>
<li>"" "&lt;b&gt; fs::get_thood_fs(com_mod, fs, lM, vmsStab, 1) &lt;/b&gt;"</li>
<li>"" "&lt;b&gt; nn::gnn(fs[1].eNoN, nsd, nsd, Nx, xql, Nqx, Jac, ksix) &lt;/b&gt;"</li>
<li>"" "&lt;b&gt; nn::gn_nxx(l, fs[0].eNoN, nsd, nsd, Nx, Nxx, xwl, Nwx, Nwxx) &lt;/b&gt;"</li>
<li>"" "&lt;b&gt; fluid_3d_m(com_mod, vmsStab, fs[0].eNoN, fs[1].eNoN, w, ksix, N0, N1, Nwx, Nqx, Nwxx, al, yl, bfl, lR, lK, K_inverse_darcy_permeability)&lt;/b&gt;" - If nsd=3</li>
<li>"" "&lt;b&gt; fluid_2d_m(com_mod, vmsStab, fs[0].eNoN, fs[1].eNoN, w, ksix, N0, N1, Nwx, Nqx, Nwxx, al, yl, bfl, lR, lK, K_inverse_darcy_permeability)&lt;/b&gt;" - If nsd=2</li>
<li>"" "&lt;b&gt; trilinos_doassem_(const_cast&lt;int&amp;&gt;(eNoN), ptr.data(), lK.data(), lR.data())&lt;/b&gt;" - If using <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a></li>
<li>&lt;b&gt; lhsa_ns::do_assem(com_mod, eNoN, ptr, lK, lR)&lt;/b&gt; - If not using <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a></li>
</ul>
</li>
</ul>
</li>
<li>&lt;b&gt; set_bc::set_bc_neu(com_mod, cm_mod, Yg, Dg) &lt;/b&gt;</li>
<li>&lt;b&gt; set_bc::set_bc_cmm(com_mod, cm_mod, Ag, Dg) &lt;/b&gt;</li>
<li>"" "&lt;b&gt; set_bc::set_bc_dir_w(com_mod, Yg, Dg) &lt;/b&gt;"</li>
<li>"" "&lt;b&gt; contact::contact_forces(com_mod, cm_mod, Dg) &lt;/b&gt;"</li>
<li>"" "&lt;b&gt; all_fun::commu(com_mod, com_mod.R) &lt;/b&gt;" - Synchronize residual R across processes</li>
<li>"" "&lt;b&gt; ustruct::ustruct_r(com_mod, Yg) &lt;/b&gt;"</li>
<li>"" "&lt;b&gt; fs::thood_val_rc(com_mod) &lt;/b&gt;"</li>
<li>"" "&lt;b&gt; set_bc::set_bc_undef_neu(com_mod) &lt;/b&gt;"</li>
<li>"" "&lt;b&gt; ls_ns::ls_solve(com_mod, eq, incL, res) &lt;/b&gt;"</li>
<li>"" "&lt;b&gt; pic::picc(simulation) &lt;/b&gt;"</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="fortran_implementation_details">Fortran Implementation </h1>
<p>The following sections provide some implementation details of the Fortran/C++ interface.</p>
<h2 id="program_main">PROGRAM MAIN </h2>
<p>Fortran main program defined in <code>MAIN.f</code>.</p>
<ul>
<li><code>sim_interface = simulation()</code> - Create a C++ <code><a class="el" href="class_simulation.html">Simulation</a></code> object, calls <code>create_simulation()</code> function.</li>
<li><code>call sim_interface % read_files(in_file_name)</code> - Read solver parameters from a solver input XML file and create all of the mesh data.</li>
</ul>
<h2 id="function_create_simulation">function create_simulation() </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI/simulation_interface_mod.f90">simulation_interface_mod.f90</a></p>
<p>Fortran / C++ interface function to create a <code><a class="el" href="class_simulation.html">Simulation</a></code> object.</p>
<ul>
<li><code>create_simulation % Simulation_object = create_simulation_c()</code> - Calls C++ <code>create_simulation</code> functon.</li>
</ul>
<h2 id="create_simulation">Simulation* create_simulation() </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp">simulation_wrap.cpp</a></p>
<p>C++ / Fortran interface function used to create a C++ <code><a class="el" href="class_simulation.html">Simulation</a></code> object and return it to Fortran.</p>
<ul>
<li><code>Simulation::Simulation()</code>- Create a C++ <a class="el" href="class_simulation.html">Simulation</a> object<ul>
<li>Create <code><a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a></code> member, set defaults in ctor</li>
<li>Create <code><a class="el" href="class_parameters.html" title="The Parameters class stores parameter values read in from a solver input file.">Parameters</a></code> member</li>
</ul>
</li>
</ul>
<h2 id="subroutine_read_files">subroutine read_files(this, file_name) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI/simulation_interface_mod.f90">simulation_interface_mod.f90</a></p>
<p>Fortran / C++ interface function used to call the C++ <code>read_files()</code> function.</p>
<ul>
<li><code>call read_files_c(this % Simulation_object, c_file_name)</code> - Call C++ <code>read_files</code> functon.</li>
</ul>
<h2 id="subroutine_distribute_data">subroutine distribute_data(this) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI/simulation_interface_mod.f90">simulation_interface_mod.f90</a></p>
<p>Fortran / C++ interface function used to call the C++ <code>()</code> function.</p>
<ul>
<li><code>call distribute_data_c(this % Simulation_object)</code></li>
</ul>
<h2 id="subroutine_initialize_solution">subroutine initialize_solution(this, timep) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI/simulation_interface_mod.f90">simulation_interface_mod.f90</a></p>
<p>Fortran / C++ interface function used to call the C++ <code>()</code> function.</p>
<ul>
<li><code>call initialize_solution_c(this % Simulation_object, timep_cptr)</code></li>
</ul>
<h2 id="subroutine_iterate_solution">subroutine iterate_solution(this) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI/simulation_interface_mod.f90">simulation_interface_mod.f90</a></p>
<ul>
<li><code>call iterate_solution_c(this % Simulation_object)</code></li>
</ul>
<h1 id="cpp_implementation_details">C++ Implementation </h1>
<p>The following sections provide some implementation details of the C++ code replicating Fortran functionality.</p>
<h2 id="read_files_c">void read_files(Simulation* simulation, const char* file_name) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp">simulation_wrap.cpp</a></p>
<p>C++ / Fortran interface function used to read in an XML file and all mesh and BC data.</p>
<ul>
<li><code>read_files_ns::read_files(simulation, std::string(file_name))</code></li>
</ul>
<h2 id="read_files_ns_read_files">void read_files_ns::read_files(Simulation* simulation, const std::string&amp; file_name) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">read_files.cpp</a></p>
<p>Read in an XML file and, all mesh and BC data. Replicates <code>SUBROUTINE READFILES</code> in <code>READFILES.f</code></p>
<ul>
<li><code><a class="el" href="class_simulation.html#aade1883dedf6e7145283f3a09fd22b7d" title="Read solver parameters.">Simulation::read_parameters()</a></code> - Read solver parameter XML file</li>
<li><code>Simulation::set_parameters()</code> - Set module (e.g.<code><a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a></code>) and <code><a class="el" href="class_simulation.html">Simulation</a></code> member data from <code><a class="el" href="class_parameters.html" title="The Parameters class stores parameter values read in from a solver input file.">Parameters</a></code> data</li>
<li><code>read_msh_ns::read_msh(simulation)</code> - Read mesh and BCs data</li>
</ul>
<h2 id="simulation_read_parameters">void <a class="el" href="class_simulation.html#aade1883dedf6e7145283f3a09fd22b7d" title="Read solver parameters.">Simulation::read_parameters(const std::string&amp; file_name)</a> </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/Simulation.cpp">Simulation.cpp</a></p>
<p>Read solver parameter XML file.</p>
<ul>
<li><code>parameters_.read_parameters(file_name)</code></li>
</ul>
<h2 id="simulation_set_module_parameters">void <a class="el" href="class_simulation.html#a11f808780839667a1055ae513ea1af51" title="Set the simulation and module member data.">Simulation::set_module_parameters()</a> </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/Simulation.cpp">Simulation.cpp</a></p>
<p>Set <code><a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a></code> module varliables.</p>
<h2 id="read_msh_ns_read_msh">void read_msh_ns::read_msh() </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Read all mesh and BCs data. Replicates <code>SUBROUTINE READMSH</code> in <code>READMSH.f</code></p>
<ul>
<li>Set the number of meshes<code>com_mod.nMsh</code></li>
<li>Allocate <code>com_mod.msh</code> storing a list of <code><a class="el" href="classmsh_type.html" title="This is the container for a mesh or NURBS patch, those specific to NURBS are noted.">mshType</a></code> objects</li>
<li>Iterate over each <code>mesh</code> in <code>com_mod.msh</code> defined by each <code>Add_mesh</code> parameter in the XML file with parameter values in <code>param</code><ul>
<li><code>load_msh::read_sv(param, mesh)</code> - Read in a volume meshes and face meshes from a VTK files</li>
<li><code>read_msh_ns::check_ien(simulation, mesh)</code> - Check the mesh element node ordering and change element node ordering if needed</li>
</ul>
</li>
<li>Re-arranging x and finding the size of the entire domain</li>
<li>Renumber face node IDs</li>
<li><code>read_fib_nff(simulation, com_mod.msh[iM], cTmp, "FIB_DIR", i)</code> - Read fiber orientation<ul>
<li><code>vtk_xml_parser::load_fiber_direction_vtu(fName, kwrd, idx, simulation-&gt;com_mod.nsd, mesh)</code></li>
</ul>
</li>
<li>Iterate over each <code>mesh</code> iM in <code>com_mod.msh</code> to set read prestress data<ul>
<li>vtk_xml::read_vtu_pdata(cTmp, "Stress", com_mod.nsd, com_mod.nsymd, 0, com_mod.msh[iM]) - Read prestress data</li>
</ul>
</li>
<li>If have prestress data then set com_mod.pS0()</li>
<li>Set initial mesh pressure, velocity or displacement from a file<ul>
<li><code>load_var_ini(simulation, com_mod)</code></li>
</ul>
</li>
</ul>
<h2 id="load_msh_read_sv">void load_msh::read_sv(Simulation* simulation, mshType&amp; mesh, const MeshParameters&amp; param) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/load_msh.cpp">load_mesh.cpp</a></p>
<p>Read mesh nodal coordinates and element connectivity. Replicates <code>SUBROUTINE READSV(list, lM)</code> in <code>LOADMSH.f</code>.</p>
<ul>
<li><code>vtk_xml::read_vtu(mesh_path, mesh)</code> - Read in volume mesh</li>
<li><code>nn::select_ele(simulation, mesh)</code> - Set mesh element properites for the input element type</li>
</ul>
<h2 id="read_vtu">void read_vtu(const std::string&amp; file_name, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml.cpp">vtk_xml.cpp</a></p>
<p>Read a mesh from a SimVascular <code>.vtu</code> file. Replicates Fortran <code>SUBROUTINE READVTU(lM, fName)</code> defined in <code>VTKXML.f</code>.</p>
<ul>
<li><code>vtk_xml_parser::load_vtk(VtkFileFormat::VTU, file_name, mesh)</code> - Read a VTK <code>.vtu</code> file and store its data into <code>mesh</code>.</li>
</ul>
<h2 id="vtk_xml_parser_load_vtk">void vtk_xml_parser::load_vtu(const std::string&amp; file_name, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml_parser.cpp">vtk_xml_parser.cpp</a></p>
<p>Read a mesh from a <code>.vtu</code> file and store its data into <code>mesh</code>. This calls VTK functions.</p>
<p>Replicates </p><div class="fragment"><div class="line">subroutine loadVTK(vtk,fName,istat)</div>
<div class="line">subroutine getVTK_numPoints(vtk,nn,istat)</div>
<div class="line">subroutine getVTK_numElems(vtk,ne,istat)</div>
<div class="line">subroutine getVTK_nodesPerElem(vtk,eNoN,istat)</div>
<div class="line">subroutine getVTK_pointCoords(vtk,x,istat)</div>
<div class="line">subroutine getVTK_elemIEN(vtk,ien,istat)</div>
</div><!-- fragment --><p> defined in <code>vtkXMLParser.f90</code>.</p>
<p>The following <code>mesh</code> variables are set </p><div class="fragment"><div class="line">mesh.gnNo - number of nodes</div>
<div class="line">mesh.x - node coordinates</div>
<div class="line">mesh.gN - node IDs </div>
<div class="line">mesh.gnEl - number of elements</div>
<div class="line">mesh.eNoN - number of noders per element</div>
<div class="line">mesh.gIEN - element connectivity (num_nodes_per_elem, num_elems)</div>
</div><!-- fragment --><h2 id="nn_select_ele">nn::select_ele(Simulation* simulation, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Set mesh variables for the input element type.</p>
<ul>
<li><code>set_3d_element_props[mesh.eNoN](mesh)</code> - Set element properties based on the number of element nodes</li>
<li><code>get_gip(simulation, mesh)</code> - Set mesh <code>w</code> and <code>xi</code> arrays used for Gauss integration</li>
<li><code>get_gnn(simulation, g, mesh)</code> - Create mesh <code>N</code> and <code>Nx</code> shape function arrays for each Gaus point <code>g</code></li>
<li><code>get_nn_bnds(simulation, mesh)</code> - Create bounds on Gauss integration points and shape functions</li>
</ul>
<h2 id="set_3d_element_props">std::map&lt;int, std::function&lt;void(int, mshType&amp;)&gt;&gt; set_3d_element_props[] </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn_elem_props.h">nn_elem_props.h</a></p>
<p>A map used to set 3D element properties based on the number of element nodes. This replicates the case statement in the Fortran 'SUBROUTINE SELECTELE(lM)' defined in NN.f.</p>
<h2 id="get_gip_mesh">nn::get_gip(Simulation* simulation, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Set mesh <code>w</code> and <code>xi</code> arrays used for Gauss integration.</p>
<ul>
<li><code>set_element_gauss_int_data[mesh.eType](mesh)</code></li>
</ul>
<h2 id="get_gnn_mesh">nn:get_gnn(Simulation* simulation, int gaus_pt, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Create mesh <code>N</code> and <code>Nx</code> shape function arrays for a Gauss point <code>gaus_pt</code>.</p>
<ul>
<li>set_element_shape_data[mesh.eType](g, mesh);</li>
</ul>
<h2 id="get_nn_bnds_mesh">nn::get_nn_bnds(Simulation* simulation, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Create bounds on Gauss integration points and shape functions. Replicates Fortran <code>SUBROUTINE GETNNBNDSlMeType, lMeNoN, lMxib, lMNb)</code>.</p>
<h2 id="read_msh_ns_check_ien">read_msh_ns::check_ien(Simulation* simulation, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Check the mesh connectivity and node ordering. It may reorder element connectivity. Replicates the Fortran <code>CHECKIEN</code> subroutine defined in <code>READMSH.f</code>.</p>
<ul>
<li><code>check_element_conn[eType](mesh)</code></li>
</ul>
<h2 id="check_element_conn">std::map&lt;consts::ElementType, std::function&lt;void(mshType&amp;)&gt;&gt; read_msh_ns::check_element_conn </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>A map of function pointers used to check element connecivity.</p>
<ul>
<li>check_tet_conn((<a class="el" href="classmsh_type.html" title="This is the container for a mesh or NURBS patch, those specific to NURBS are noted.">mshType</a>&amp; mesh)</li>
<li>check_wedge_conn(mshType&amp; mesh)</li>
</ul>
<h2 id="vtk_xml_read_vtp">vtk_xml::read_vtp(const std::string&amp; file_name, faceType&amp; face) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml.cpp">vtk_xml.cpp</a></p>
<p>Read a face nodal coordinates and element connectivity from a <code>SimVascular</code> <code>.vtp</code> file. Sets data in <code><a class="el" href="classface_type.html" title="The face type containing mesh at boundary.">faceType</a></code> face:</p><ul>
<li>face.eNoN - number of noders per element</li>
<li>face.gebc - EBC array (gE + gIEN)</li>
<li>face.gnEl - globel number of elements</li>
<li>face.nEl - number of elements</li>
<li>face.nNo - number of nodes</li>
<li>face.x - node coordinates</li>
</ul>
<p>Replicates Fortran READVTP subroutine defined in VTKXML.f.</p>
<ul>
<li><code>vtk_xml_parser::load_vtp(file_name, face)</code></li>
</ul>
<h2 id="vtk_xml_parser_load_vtp">vtk_xml_parser::load_vtp(const std::string&amp; file_name, faceType&amp; face) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml_parser.cpp">vtk_xml_parser.cpp</a></p>
<p>Store a surface mesh read in from a VTK <code>.vtp</code> file into a <a class="el" href="classface_type.html" title="The face type containing mesh at boundary.">faceType</a> object.</p>
<ul>
<li>auto vtk_polydata = reader-&gt;GetOutput()</li>
<li>auto points = vtk_polydata-&gt;GetPoints()</li>
<li>store_nodal_coords(points, face)</li>
<li><code>store_nodal_ids(vtk_polydata, face)</code></li>
<li><code>store_element_conn(vtk_polydata, face)</code></li>
<li><code>store_element_ids(vtk_polydata, face)</code></li>
</ul>
<h2 id="nn_select_eleb">nn::select_eleb(Simulation* simulation, mshType&amp; mesh, faceType&amp; face)) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Set face properties for the input element type.</p>
<ul>
<li><code>get_gip(simulation, face)</code></li>
<li><code>get_gnn(simulation, g, face)</code></li>
</ul>
<h2 id="set_face_element_props">std::map&lt;int, std::function&lt;void(int, mshType&amp;)&gt;&gt; set_face_element_props </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn_elem_props.h">nn_elem_props.h</a></p>
<p>A map type used to set element properties.</p>
<h2 id="get_gip_face">get_gip(Simulation* simulation, faceType&amp; face) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<ul>
<li><code>set_face_gauss_int_data[face.eType](face)</code></li>
</ul>
<h2 id="get_gnn_face">get_gnn(Simulation* simulation, int gaus_pt, faceType&amp; face) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Computes shape functions and derivatives at given natural coords.</p>
<ul>
<li><code>set_face_shape_data[face.eType](gaus_pt, face)</code></li>
</ul>
<h2 id="set_projector">set_projector(simulation, avNds) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Associates two faces with each other and sets gN, matches the nodal coordinates for each projection face.</p>
<ul>
<li><code>all_fun::find_face(com_mod.msh, ctmpi, iM, iFa)</code></li>
<li><code>match_faces(com_mod, face1, face2, tol, lPrj)</code></li>
</ul>
<h2 id="find_face">find_face(com_mod.msh, ctmpi, iM, iFa) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/all_fun.cpp">all_fun.cpp</a></p>
<h2 id="match_faces">match_faces(const ComMod&amp; com_mod, const faceType&amp; lFa, const faceType&amp; pFa, const double ptol, utils::stackType&amp; lPrj) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Match isoparameteric faces to each other.</p>
<ul>
<li><code>find_blk(nsd, nBkd, nFlt, xMin, dx, coord)</code></li>
</ul>
<h2 id="find_blk">int find_blk(const int nsd, const int nBkd, const std::vector&lt;bool&gt;&amp; nFlt, const Vector&lt;double&gt;&amp;xMin, const Vector&lt;double&gt;&amp;dx, const Vector&lt;double&gt;&amp; x) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Compute the block ID for the given coordinate.</p>
<h2 id="read_fib_nff">read_fib_nff(Simulation* simulation, mshType&amp; mesh, const std::string&amp; fName, const std::string&amp; kwrd, const int idx) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Read fiber direction from a vtu file.</p>
<ul>
<li><code>vtk_xml_parser::load_fiber_direction_vtu(fName, kwrd, idx, simulation-&gt;com_mod.nsd, mesh)</code></li>
</ul>
<h2 id="load_fiber_direction_vtu">load_fiber_direction_vtu(const std::string&amp; file_name, const std::string&amp; data_name, const int idx, const int nsd, <a class="el" href="classmsh_type.html" title="This is the container for a mesh or NURBS patch, those specific to NURBS are noted.">mshType</a>&amp; mesh" &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml_parser.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml_parser.cpp</a>" &gt;vtk_xml_parser.cpp&lt;/a&gt;

Read fiber direction data from a VTK VTU file and copy it into a mesh. 






&lt;h2 id="read_vtu_pdata"&gt;  read_vtu_pdata(const std::string&amp; fName, const std::string&amp; kwrd, const int nsd, const int m, const int idx, mshType&amp; mesh) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml.cpp</a>" &gt;vtk_xml.cpp&lt;/a&gt;

Read prestress data from a vtu file. 

@icode 
  auto vtk_data = VtkData::create_reader(fName);
  int num_elems = vtk_data-&gt;num_elems();
  int num_points = vtk_data-&gt;num_points();
@endicode 





&lt;h2 id="load_var_ini"&gt;  load_var_ini(Simulation* simulation, ComMod&amp; com_mod) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp</a>" &gt;read_msh.cpp&lt;/a&gt;

Read initial field values (pressure, velocity or displacement). 






&lt;h2 id="read_eq"&gt;  read_eq(Simulation* simulation, EquationParameters&amp; eq_params, eqType&amp; lEq) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp</a>" &gt;read_files.cpp&lt;/a&gt;

Set equation parameters.

- &lt;tt&gt;set_equation_properties(simulation, eq_params, lEq, propL, outPuts, nDOP)&lt;/tt&gt;






&lt;h2 id="set_equation_properties"&gt; set_equation_properties(Simulation* simulation, EquationParameters&amp; eq_params, eqType&amp; lEq, EquationProps&amp; propL, 
EquationOutputs&amp; outPuts, EquationNdop&amp; nDOP) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp</a>" &gt;read_files.cpp&lt;/a&gt;

Set equation properties.

- eq_type = equation_name_to_type.at(eq_type_str)

- &lt;tt&gt;set_equation_props[eq_type](simulation, eq_params, lEq, propL, outPuts, nDOP)&lt;/tt&gt; - Execute function based on 'eq_type'






&lt;h2 id="set_equation_props"&gt; std::map&lt;consts::EquationType, std::function&amp;lt;void(Simulation*, EquationParameters&amp;, eqType&amp;, EquationProps&amp;, 
EquationOutputs&amp;, EquationNdop&amp;)&amp;gt;&amp;gt;) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/set_equation_props.h">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/set_equation_props.h</a>" &gt;set_equation_props.h&lt;/a&gt;

A map of lambda functions used to set equation properties.






&lt;h2 id="read_outputs"&gt; read_outputs(Simulation* simulation, EquationParameters&amp; eq_params, eqType&amp; lEq, EquationNdop&amp; nDOP,  EquationOutputs&amp; outPuts) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp</a>" &gt;read_files.cpp&lt;/a&gt;

Set output parameters.






&lt;h2 id="read_bc"&gt;  read_bc(Simulation* simulation, EquationParameters&amp; eq_params, eqType&amp; lEq, BoundaryConditionParameters&amp; bc_params, bcType&amp; lBc) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp</a>" &gt;read_files.cpp&lt;/a&gt;

Read boundary condition data.

- &lt;tt&gt;read_trac_bcff(com_mod, lBc.gm, com_mod.msh[iM].fa[iFa], file_name)&lt;/tt&gt;
- &lt;tt&gt;read_temporal_values_file(file_name, lBc)&lt;/tt&gt; 
- &lt;tt&gt;read_fourier_coeff_values_file(file_name, lBc)&lt;/tt&gt;
- &lt;tt&gt;read_bct(com_mod, lBc.gm, com_mod.msh[iM].fa[iFa], file_name)&lt;/tt&gt;
- &lt;tt&gt;read_temporal_and_spatial_values_file(com_mod, com_mod.msh[iM], com_mod.msh[iM].fa[iFa], file_name, lBc)&lt;/tt&gt;
- &lt;tt&gt;read_spatial_values_file(com_mod, com_mod.msh[iM], com_mod.msh[iM].fa[iFa], file_name, lBc)&lt;/tt&gt;
- &lt;tt&gt;vtk_xml::read_vtp_pdata(cTmp, "Stress", com_mod.nsd, com_mod.nsymd, data_series, face)&lt;/tt&gt;
- &lt;tt&gt;vtk_xml::read_vtp_pdata(cTmp, "Displacement", com_mod.nsd, com_mod.nsd, data_series, face)&lt;/tt&gt;






&lt;h2 id="read_trac_bcff"&gt; read_trac_bcff(ComMod&amp; com_mod, MBType&amp; lMB, faceType&amp; lFa, const std::string&amp; fName) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp</a>" &gt;read_files.cpp&lt;/a&gt;

Reads pressure/traction data from a vtp file and stores in moving BC data structure.

@icode 
VtkVtpData vtp_data(fName)
int num_points = vtp_data.num_points();
@endicode 





&lt;h2 id="read_temporal_values_file"&gt; read_temporal_values_file(const std::string&amp; file_name, bcType&amp; lBc)  &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp</a>" &gt;read_files.cpp&lt;/a&gt;

Set boundary condition temporal values read in from a file. 






&lt;h2 id="read_fourier_coeff_values_file"&gt; read_fourier_coeff_values_file(const std::string&amp; file_name, bcType&amp; lBc) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp</a>" &gt;read_files.cpp&lt;/a&gt;

Set boundary condition Fourier coefficients read in from a file.





&lt;h2 id="read_bct"&gt; read_bct(ComMod&amp; com_mod, MBType&amp; lMB, faceType&amp; lFa, const std::string&amp; fName) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp</a>" &gt;read_files.cpp&lt;/a&gt;

Reads general velocity data from bct.vtp.

@icode 
  VtkVtpData vtp_data(fName);
  int num_points = vtp_data.num_points();
  if (num_points == 0) {
@endicode 





&lt;h2 id="read_spatial_values_file"&gt; read_spatial_values_file(const ComMod&amp; com_mod, const mshType&amp; msh, const faceType&amp; lFa,
    const std::string&amp; file_name, bcType&amp; lBc) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp</a>" &gt;read_files.cpp&lt;/a&gt;

Read in a file containing spatial values used for a boundary condition.





&lt;h2 id="distribute_data"&gt; distribute_data(Simulation* simulation) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp</a>" &gt;simulation_wrap.cpp&lt;/a&gt;

C++ / Fortran interface function used to distribute data to MPI processes. 

- &lt;tt&gt;distribute(simulation)&lt;/tt&gt;





&lt;h2 id="distribute"&gt; distribute(Simulation* simulation)  &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp</a>" &gt;distribute.cpp&lt;/a&gt;

Partition and distribute data across processors.

- &lt;tt&gt;all_fun::split_jobs(task_id, nMsh, num_proc, wgt, wrk)&lt;/tt&gt;

- &lt;tt&gt;part_msh(simulation, com_mod.msh[iM], gmtl, num_proc, iWgt)&lt;/tt&gt;

- &lt;tt&gt;part_face(simulation, msh, face, tMs[iM].fa[iFa], gmtl)&lt;/tt&gt;






&lt;h2 id="bcast"&gt; cmType::bcast(const CmMod&amp; cm_mod, ...) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/CmMod.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/CmMod.cpp</a>" &gt;CmMod.cpp&lt;/a&gt;

Interfacee to &lt;tt&gt;MPI_Bcast()&lt;/tt&gt;.






&lt;h2 id="split_jobs"&gt; split_jobs(int tid, int m, int n, Array&lt;double&gt;&amp; A, Vector&lt;double&gt;&amp; b) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/all_fun.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/all_fun.cpp</a>" &gt;all_fun.cpp&lt;/a&gt;

Spliting "m" jobs between "n" workers.






&lt;h2 id="part_msh"&gt; part_msh(Simulation* simulation, mshType&amp; lM, Vector&lt;int&gt;&amp; gmtl, int nP, Vector&lt;float&gt;&amp; wgt) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp</a>" &gt;distribute.cpp&lt;/a&gt;

Partition a mesh amongst N processors.

- Broadcast mesh data.
@icode 
  cm.bcast(cm_mod, &amp;lM.lShpF);
  cm.bcast(cm_mod, &amp;lM.lShl);
  cm.bcast(cm_mod, &amp;lM.lFib);

  cm.bcast(cm_mod, &amp;eType);

  cm.bcast(cm_mod, &amp;lM.eNoN);
  cm.bcast(cm_mod, &amp;lM.nFa);
  cm.bcast(cm_mod, &amp;lM.nFs);
  cm.bcast(cm_mod, &amp;lM.nG);
  cm.bcast(cm_mod, &amp;lM.gnEl);
  cm.bcast(cm_mod, &amp;lM.gnNo);
  cm.bcast(cm_mod, lM.name);
  cm.bcast(cm_mod, &amp;lM.nFn);
  cm.bcast(cm_mod, &amp;lM.scF);
@endicode 

- Set face properties for the input element type
@icode 
nn::select_ele(simulation, lM)`
@endicode 

- Scattering the lM.gIEN array to all processors.
@icode 
  MPI_Scatterv(lM.gIEN.data_, sCount.data_, disp.data_, cm_mod::mpint, lM.IEN.data_, nEl*eNoN, cm_mod::mpint, cm_mod.master, cm.com())
@endicode 

- Doing partitioning, using ParMetis
@icode 
  auto edgecut = split_(&amp;nEl, &amp;eNoN, &amp;eNoNb, lM.IEN.data_, &amp;num_proc, lM.eDist.data_,  wgt.data_, part.data_)`
@endicode 

- Gathering the parts inside master
@icode 
  MPI_Gatherv(part.data_, nEl, cm_mod::mpint, gPart.data_, sCount.data_, disp.data_, cm_mod::mpint, cm_mod.master, cm.com())
@endicode 

- Communicating eId, if neccessary
@icode 
   MPI_Scatterv(tempIEN.data_, sCount.data_, disp.data_, cm_mod::mpint, lM.IEN.data_, nEl*eNoN, cm_mod::mpint, cm_mod.master, cm.com())
@endicode 

- Communicating fN, if neccessary
@icode 
  MPI_Scatterv(tmpFn.data_, sCount.data_, disp.data_, cm_mod::mpreal, lM.fN.data_, nEl*nFn*nsd, cm_mod::mpreal, cm_mod.master, cm.com());
@endicode 

- scattering the sorted lM%IEN to all processors.
@icode 
  MPI_Scatterv(tempIEN.data_, sCount.data_, disp.data_, cm_mod::mpint, lM.IEN.data_, nEl*eNoN, cm_mod::mpint, cm_mod.master, cm.com());
@endicode 

- Constructing the initial global to local pointer






&lt;h2 id="part_face"&gt; part_face(Simulation* simulation, mshType&amp; lM, faceType&amp; lFa, faceType&amp; gFa, Vector&lt;int&gt;&amp; gmtl) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp</a>" &gt;distribute.cpp&lt;/a&gt;

Partition faces across processors.

- Broadcast the number of nodes and elements of to slaves 
@icode 
  cm.bcast(cm_mod, &amp;gFa.d);
  cm.bcast(cm_mod, &amp;gFa.eNoN);
  cm.bcast(cm_mod, &amp;gFa.iM);
  cm.bcast(cm_mod, &amp;gFa.nEl);
  cm.bcast(cm_mod, &amp;gFa.gnEl);
  cm.bcast(cm_mod, &amp;gFa.nNo);
@endicode 

- &lt;tt&gt;nn::select_eleb(simulation, lM, gFa)&lt;/tt&gt; - Set face properties for the input element type.






&lt;h2 id="dist_eq"&gt; dist_eq(ComMod&amp; com_mod, const CmMod&amp; cm_mod, const cmType&amp; cm, const std::vector&lt;mshType&gt;&amp; tMs, 
const Vector&lt;int&gt;&amp; gmtl, CepMod&amp; cep_mod, eqType&amp; lEq) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp</a>" &gt;distribute.cpp&lt;/a&gt;

Distribute equation data to processors.

- Distribute equation parameters
@icode 
  cm.bcast(cm_mod, &amp;lEq.nOutput);
  cm.bcast(cm_mod, &amp;lEq.coupled);
  cm.bcast(cm_mod, &amp;lEq.maxItr);
  cm.bcast(cm_mod, &amp;lEq.minItr);
  cm.bcast(cm_mod, &amp;lEq.roInf);
  cm.bcast_enum(cm_mod, &amp;lEq.phys);
  ...
@endicode 

- Distribute linear solver settings
@icode 
  cm.bcast(cm_mod, &amp;lEq.FSILS.foC);
  cm.bcast_enum(cm_mod, &amp;lEq.FSILS.LS_type);
  cm.bcast(cm_mod, &amp;lEq.FSILS.RI.relTol);
  cm.bcast(cm_mod, &amp;lEq.FSILS.GM.relTol);
  cm.bcast(cm_mod, &amp;lEq.FSILS.CG.relTol);
  ...
@endicode 

- Distribute domain properties

- &lt;tt&gt;dist_mat_consts(com_mod, cm_mod, cm, dmn.stM)&lt;/tt&gt;






&lt;h2 id="dist_mat_consts"&gt;  dist_mat_consts(const ComMod&amp; com_mod, const CmMod&amp; cm_mod, const cmType&amp; cm, stModelType&amp; lStM) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp</a>" &gt;distribute.cpp&lt;/a&gt;

Distribute material properties to all processors.






&lt;h2 id="dist_bc"&gt;  dist_bc(ComMod&amp; com_mod, const CmMod&amp; cm_mod, const cmType&amp; cm, bcType&amp; lBc, const std::vector&lt;mshType&gt;&amp; tMs, const Vector&lt;int&gt;&amp; gmtl) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp</a>" &gt;distribute.cpp&lt;/a&gt;

Distribute boundary condition data to all processors.






&lt;h2 id="dist_visc_model"&gt;  dist_visc_model(const ComMod&amp; com_mod, const CmMod&amp; cm_mod, const cmType&amp; cm, fluidViscModelType&amp; lVis) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp</a>" &gt;distribute.cpp&lt;/a&gt;

Distribute viscosity model to processors. 






&lt;h2 id="dist_bf"&gt;  dist_bf(ComMod&amp; com_mod, const CmMod&amp; cm_mod, const cmType&amp; cm, bfType&amp; lBf) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp</a>" &gt;distribute.cpp&lt;/a&gt;

Distribute boundary fource to processors. 






&lt;h2 id="initialize_solution"&gt; initialize_solution(Simulation* simulation, double* timep) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp</a>" &gt;simulation_wrap.cpp&lt;/a&gt;

C++ / Fortran interface function used to initialize the solution. 

- &lt;tt&gt;initialize(simulation, timeP)&lt;/tt&gt;





&lt;h2 id="initialize"&gt; initialize(Simulation* simulation, Vector&lt;double&gt;&amp; timeP) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/initialize.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/initialize.cpp</a>" &gt;initialize.cpp&lt;/a&gt;

 Initialize or finalize svFSI variables/structures.

 Sets the following for each com_mod.eq[].
 @icode 
  eq.am
  eq.dof
  eq.pNorm
  eq.af
  eq.beta
  eq.gam
  eq.s
  eq.e
 
  com_mod.Ao.resize(tDof,tnNo);
  com_mod.An.resize(tDof,tnNo);
  com_mod.Yo.resize(tDof,tnNo);
  com_mod.Yn.resize(tDof,tnNo);
  com_mod.Do.resize(tDof,tnNo);
  com_mod.Dn.resize(tDof,tnNo);
  com_mod.Bf.resize(nsd,tnNo);
 
  com_mod.An = com_mod.Ao;
  com_mod.Yn = com_mod.Yo;
  com_mod.Dn = com_mod.Do;

@endicode 

- &lt;tt&gt;mat_fun::ten_init(nsd)&lt;/tt&gt;

- &lt;tt&gt;lhsa_ns::lhsa(simulation, nnz)&lt;/tt&gt; - Constructing stiffness matrix

- &lt;tt&gt;fsi_linear_solver::fsils_lhs_create(com_mod.lhs, communicator, com_mod.gtnNo, com_mod.tnNo, nnz,
      com_mod.ltg, com_mod.rowPtr, com_mod.colPtr, nFacesLS)&lt;/tt&gt;

- &lt;tt&gt;cep_ion::cep_init(simulation)&lt;/tt&gt;

- &lt;tt&gt;fs::init_fs_msh(com_mod, mesh)&lt;/tt&gt;

- &lt;tt&gt;baf_ini_ns::baf_ini(simulation)&lt;/tt&gt;

- &lt;tt&gt;set_bc::set_bc_dir(com_mod, com_mod.Ao, com_mod.Yo, com_mod.Do)&lt;/tt&gt;

- &lt;tt&gt;txt_ns::txt(simulation, true)&lt;/tt&gt;





&lt;h2 id="lsh"&gt; void lhsa(Simulation* simulation, int&amp; nnz) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/lhsa.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/lhsa.cpp</a>" &gt;lhsa.cpp&lt;/a&gt;

Create data structure and assembling LHS sparse matrix.

Modifies:
 @icode 
 com_mod.idMap
 com_mod.colPtr
 com_mod.rowPtr
 @endicode 





&lt;h2 id="fsils_commu_create"&gt;  void fsils_commu_create(FSILS_commuType&amp; commu, cm_mod::MpiCommWorldType commi) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSILS_cinterface/commu.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSILS_cinterface/commu.cpp</a>" &gt;commu.cpp&lt;/a&gt;

Modifies:
 @icode 
  commu.task
  commu.nTasks
  
  commu.foC = true;
  commu.comm = commi;
  commu.nTasks = 1;
  commu.task   = 0;
  commu.master = 0;
 @endicode 






&lt;h2 id="fsils_lhs_create"&gt; void fsils_lhs_create(FSILS_lhsType&amp; lhs, FSILS_commuType&amp; commu, int gnNo, int nNo, int nnz, Vector&lt;int&gt;&amp; gNodes, Vector&lt;int&gt; &amp;rowPtr, Vector&lt;int&gt;&amp; colPtr, int nFaces) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSILS_cinterface/lhs.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSILS_cinterface/lhs.cpp</a>" &gt;lhs.cpp&lt;/a&gt;

Create data structure and assembling LHS sparse matrix.

Modifies:
@icode 
  lhs.foC 
  lhs.gnNo 
  lhs.nNo 
  lhs.nnz 
  lhs.commu 
  lhs.nFaces 
  lhs.mynNo 

  lhs.colPtr
  lhs.rowPtr
  lhs.diagPtr
  lhs.map
  lhs.face
@endicode 





&lt;h2 id="cep_init"&gt; void cep_init(Simulation* simulation) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/cep_ion.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/cep_ion.cpp</a>" &gt;cep_ion.cpp&lt;/a&gt;

 Modifies
 @icode 
 cep_mod.Xion
 @endicode 

 - &lt;tt&gt;cep_init_l(cep_mod, eq.dmn[iDmn].cep, nX, nG, Xl, Xgl)&lt;/tt&gt;

 - &lt;tt&gt;all_fun::commu(com_mod, sA)&lt;/tt&gt;
 - &lt;tt&gt;all_fun::commu(com_mod, sF)&lt;/tt&gt;





&lt;h2 id="init_fs_msh"&gt; void init_fs_msh(const ComMod&amp; com_mod, mshType&amp; lM) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/fs.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/fs.cpp</a>" &gt;fs.cpp&lt;/a&gt;

 Modifies
 @icode 
  lM.fs.resize(lM.nFs)
  lM.fs[0].lShpF = lM.lShpF;
  lM.fs[0].eType = lM.eType;
  lM.fs[0].eNoN  = lM.eNoN;
  lM.fs[0].nG    = lM.nG;
 @endicode 

 - &lt;tt&gt;nn::get_gn_nxx(insd, ind2, lM.fs[0].eType, lM.fs[0].eNoN, g, lM.fs[0].xi, lM.fs[0].Nxx)&lt;/tt&gt;

 - &lt;tt&gt;set_thood_fs(lM.fs[1], lM.fs[0].eType)&lt;/tt&gt;

 - &lt;tt&gt;alloc_fs(lM.fs[1], nsd, insd)&lt;/tt&gt;






&lt;h2 id="baf_ini"&gt; void baf_ini(Simulation* simulation) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/baf_ini.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/baf_ini.cpp</a>" &gt;baf_ini.cpp&lt;/a&gt;

 Modifies
 @icode 
   com_mod.cplBC.fa
   com_mod.cplBC.xn

   com_mod.cplBC.fa[i].RCR.Rp = bc.RCR.Rp;
   com_mod.cplBC.fa[i].RCR.C  = bc.RCR.C;
   com_mod.cplBC.fa[i].RCR.Rd = bc.RCR.Rd;
   com_mod.cplBC.fa[i].RCR.Pd = bc.RCR.Pd;
   com_mod.cplBC.fa[i].RCR.Xo = bc.RCR.Xo;

 @endicode 

 - &lt;tt&gt;face_ini(simulation, msh, face)&lt;/tt&gt; - Compute face normals and area

 - &lt;tt&gt;shl_ini(com_mod, cm_mod, com_mod.msh[iM])&lt;/tt&gt;

 - &lt;tt&gt;bc_ini(com_mod, cm_mod, bc, com_mod.msh[iM].fa[iFa])&lt;/tt&gt; - Initialize face BC profile

 - &lt;tt&gt;shl_bc_ini(com_mod, cm_mod, bc, com_mod.msh[iM].fa[iFa], com_mod.msh[iM])&lt;/tt&gt;

 - &lt;tt&gt;set_bc::rcr_init(com_mod, cm_mod)&lt;/tt&gt;

 - &lt;tt&gt;set_bc::genBC_Integ_X(com_mod, cm_mod, "I")&lt;/tt&gt;

 - &lt;tt&gt;set_bc::calc_der_cpl_bc(com_mod, cm_mod)&lt;/tt&gt;

 - &lt;tt&gt;fsi_ls_ini(com_mod, cm_mod, bc, com_mod.msh[iM].fa[iFa], lsPtr)&lt;/tt&gt;

 - &lt;tt&gt;fsils_bc_create(com_mod.lhs, lsPtr, i, nsd, BcType::BC_TYPE_Dir, gNodes)&lt;/tt&gt;







&lt;h2 id="fsi_ls_ini"&gt; void fsi_ls_ini(ComMod&amp; com_mod, const CmMod&amp; cm_mod, bcType&amp; lBc, const faceType&amp; lFa, int&amp; lsPtr) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/baf_ini.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/baf_ini.cpp</a>" &gt;baf_ini.cpp&lt;/a&gt;

 Modifies
 @icode 
 
 @endicode 

 - &lt;tt&gt;fsils_bc_create(com_mod.lhs, lsPtr, lFa.nNo, nsd, BcType::BC_TYPE_Dir, gNodes, sVl)&lt;/tt&gt;






&lt;h2 id="fsils_bc_create"&gt; void fsils_bc_create(FSILS_lhsType&amp; lhs, int faIn, int nNo, int dof, BcType BC_type, const Vector&lt;int&gt;&amp; gNodes,
    Array&lt;double&gt; Val) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSILS_cinterface/bc.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSILS_cinterface/bc.cpp</a>" &gt;bc.cpp&lt;/a&gt;

 Modifies
 @icode 
 lhs.face[faIn]
 @endicode 

 - &lt;tt&gt;MPI_Allreduce(\&amp;a, \&amp;Ac, 1, cm_mod::mpint, MPI_SUM, lhs.commu.comm)&lt;/tt&gt;

 - &lt;tt&gt;fsils_commuv(lhs, dof, v)&lt;/tt&gt;






&lt;h2 id="set_bc_dir"&gt; void set_bc_dir(ComMod&amp; com_mod, Array&lt;double&gt;&amp; lA, Array&lt;double&gt;&amp; lY, Array&lt;double&gt;&amp; lD) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/set_bc.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/set_bc.cpp</a>" &gt;set_bc.cpp&lt;/a&gt;

 Modifies
 @icode 
com_mod.Ad
lA(tDof, tnNo)
lY(tDof, tnNo)
lD(tDof, tnNo)
 @endicode 

 - &lt;tt&gt;set_bc::set_bc_dir_l(com_mod, bc, com_mod.msh[iM].fa[iFa], tmpA, tmpY, lDof)&lt;/tt&gt;





&lt;h2 id="set_bc_dir_l"&gt; void set_bc_dir_l(ComMod&amp; com_mod, const bcType&amp; lBc, const faceType&amp; lFa, Array&lt;double&gt;&amp; lA, Array&lt;double&gt;&amp; lY, int lDof) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/set_bc.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/set_bc.cpp</a>" &gt;set_bc.cpp&lt;/a&gt;

 Modifies
 @icode 
 @endicode 

 - &lt;tt&gt;igbc(com_mod, lBc.gm, lY, lA)&lt;/tt&gt; - calculating values by the inverse of general BC

 - &lt;tt&gt;ifft(com_mod, lBc.gt, dirY_v, dirA_v)&lt;/tt&gt;






&lt;h2 id="iterate_solution"&gt; void iterate_solution(Simulation* simulation) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp</a>" &gt;simulation_wrap.cpp&lt;/a&gt;

 - &lt;tt&gt;read_msh_ns::calc_mesh_props(com_mod, cm_mod, com_mod.nMsh, com_mod.msh)&lt;/tt&gt;

 - &lt;tt&gt;pic::picp(simulation)&lt;/tt&gt;

 - &lt;tt&gt;set_bc::set_bc_dir(com_mod, An, Yn, Dn)&lt;/tt&gt;

 - Inner loop for iteration
   - &lt;tt&gt;set_bc::set_bc_cpl(com_mod, cm_mod)&lt;/tt&gt;
   - &lt;tt&gt;set_bc::set_bc_dir(com_mod, An, Yn, Dn)&lt;/tt&gt;
   - &lt;tt&gt;pic::pici(simulation, Ag, Yg, Dg)&lt;/tt&gt;
   - &lt;tt&gt;ls_ns::ls_alloc(com_mod, eq)&lt;/tt&gt;
   - &lt;tt&gt;bf::set_bf(com_mod, Dg)&lt;/tt&gt;
   - &lt;tt&gt;eq_assem::global_eq_assem(com_mod, com_mod.msh[iM], Ag, Yg, Dg)&lt;/tt&gt; - For each mesh
   - &lt;tt&gt;set_bc::set_bc_neu(com_mod, cm_mod, Yg, Dg)&lt;/tt&gt;
   - &lt;tt&gt;set_bc::set_bc_cmm(com_mod, cm_mod, Ag, Dg)&lt;/tt&gt;
   - &lt;tt&gt;set_bc::set_bc_dir_w(com_mod, Yg, Dg)&lt;/tt&gt; - Apply weakly applied Dirichlet BCs
   - &lt;tt&gt;contact::contact_forces(com_mod, cm_mod, Dg)&lt;/tt&gt;
   - &lt;tt&gt;all_fun::commu(com_mod, com_mod.R)&lt;/tt&gt; - Synchronize residual across processes
   - &lt;tt&gt;ustruct::ustruct_r(com_mod, Yg)&lt;/tt&gt;
   - &lt;tt&gt;fs::thood_val_rc(com_mod)&lt;/tt&gt;
   - &lt;tt&gt;set_bc::set_bc_undef_neu(com_mod)&lt;/tt&gt;
   - &lt;tt&gt;ls_ns::ls_solve(com_mod, eq, incL, res)&lt;/tt&gt;
   - &lt;tt&gt;pic::picc(simulation)&lt;/tt&gt;





&lt;h2 id="picp"&gt; void picp(Simulation* simulation) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/pic.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/pic.cpp</a>" &gt;pic.cpp&lt;/a&gt;

Modifies
 @icode 
 pS0 
 Ad 
 Ao 
 Yo 
 Do 
 An 
 Yn 
 Dn 
@endicode 

 - &lt;tt&gt;cep_ion::cep_integ(simulation, iEq, e, Do)&lt;/tt&gt;






&lt;h2 id="ls_alloc"&gt; void ls_alloc(ComMod&amp; com_mod, eqType&amp; lEq) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/ls.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/ls.cpp</a>" &gt;ls.cpp&lt;/a&gt;

Allocate &lt;tt&gt;com_mod.R&lt;/tt&gt; and &lt;tt&gt;com_mod.Val&lt;/tt&gt; arrays.

Modifies
@icode 
  com_mod.R - Residual vector
  com_mod.Val - LHS matrix
@endicode 

 - if using trilinos
   - &lt;tt&gt;trilinos_lhs_create_(gtnNo, lhs.mynNo, tnNo, lhs.nnz, tls.ltg.data(), com_mod.ltg.data(), com_mod.rowPtr.data(),
        com_mod.colPtr.data(), dof)&lt;/tt&gt;






&lt;h2 id="set_bf"&gt; void set_bf(ComMod&amp; com_mod, Array&lt;double&gt;&amp; Dg) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/bf.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/bf.cpp</a>" &gt;bf.cpp&lt;/a&gt;

 - &lt;tt&gt;set_bf_l(com_mod, eq.bf[iBf], com_mod.msh[iM], Dg)&lt;/tt&gt;





&lt;h2 id="set_bf_l"&gt; void set_bf_l(ComMod&amp; com_mod, bfType&amp; lBf, mshType&amp; lM, Array&lt;double&gt;&amp; Dg) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/bf.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/bf.cpp</a>" &gt;bf.cpp&lt;/a&gt;

 Modifies
 @icode 
   com_mod.Bf
 @endicode 

- &lt;tt&gt;ifft(com_mod, lBf.bt, f, rtmp)&lt;/tt&gt; - If BodyForceType::bfType_ustd

- &lt;tt&gt;igbc(com_mod, lBf.bm, bfl, xl)&lt;/tt&gt; - If BodyForceType::bfType_gen

- &lt;tt&gt;bf_construct(com_mod, lM, e, eNoN, idof, xl, dl, bfl, ptr)&lt;/tt&gt;





&lt;h2 id="bf_construct"&gt; void bf_construct(ComMod&amp; com_mod, const mshType&amp; lM, const int e, const int eNoN, const int idof, Array&lt;double&gt;&amp; xl,
    const Array&lt;double&gt;&amp; dl, const Array&lt;double&gt;&amp; bfl, const Vector&lt;int&gt;&amp; ptr) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/bf.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/bf.cpp</a>" &gt;bf.cpp&lt;/a&gt;

 - &lt;tt&gt;cmm::bcmmi(com_mod, eNoN, idof, w, N, Nx, xl, bfl, lR)&lt;/tt&gt;

 - &lt;tt&gt;trilinos_doassem_(const_cast\&lt;int\&amp;\&gt;(eNoN), ptr.data(), lK.data(), lR.data())&lt;/tt&gt; - If using Trilinos

 - &lt;tt&gt;lhsa_ns::do_assem(com_mod, eNoN, ptr, lK, lR)&lt;/tt&gt; - If not using Trilinos






&lt;h2 id="global_eq_assem"&gt; void global_eq_assem(ComMod&amp; com_mod, const mshType&amp; lM, const Array&lt;double&gt;&amp; Ag, const Array&lt;double&gt;&amp; Yg, const Array&lt;double&gt;&amp; Dg) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/eq_assem.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/eq_assem.cpp</a>" &gt;eq_assem.cpp&lt;/a&gt;

 - `fluid::construct_fluid(com_mod, lM, Ag, Yg) -  If EquationType::phys_fluid





&lt;h2 id="construct_fluid"&gt; void construct_fluid(ComMod&amp; com_mod, const mshType&amp; lM, const Array&lt;double&gt;&amp; Ag, const Array&lt;double&gt;&amp; Yg) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/fluid.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/fluid.cpp</a>" &gt;fluid.cpp&lt;/a&gt;

This is for solving fluid transport equation solving Navier-Stokes equations. Dirichlet boundary conditions are either treated
strongly or weakly.

 - &lt;tt&gt;fs::get_thood_fs(com_mod, fs, lM, vmsStab, 1)&lt;/tt&gt;

 - &lt;tt&gt;nn::gnn(fs[1].eNoN, nsd, nsd, Nx, xql, Nqx, Jac, ksix)&lt;/tt&gt; 

 - &lt;tt&gt;nn::gn_nxx(l, fs[0].eNoN, nsd, nsd, Nx, Nxx, xwl, Nwx, Nwxx)&lt;/tt&gt;

 - &lt;tt&gt;fluid_3d_m(com_mod, vmsStab, fs[0].eNoN, fs[1].eNoN, w, ksix, N0, N1, Nwx, Nqx, Nwxx, al, yl, bfl, lR, lK, K_inverse_darcy_permeability)&lt;/tt&gt; - If nsd=3

 - &lt;tt&gt;fluid_2d_m(com_mod, vmsStab, fs[0].eNoN, fs[1].eNoN, w, ksix, N0, N1, Nwx, Nqx, Nwxx, al, yl, bfl, lR, lK, K_inverse_darcy_permeability)&lt;/tt&gt; - If nsd=2

 - &lt;tt&gt;trilinos_doassem_(const_cast\&lt;int\&amp;\&gt;(eNoN), ptr.data(), lK.data(), lR.data())&lt;/tt&gt; - If using Trilinos

 - &lt;tt&gt;lhsa_ns::do_assem(com_mod, eNoN, ptr, lK, lR)&lt;/tt&gt; - If not using Trilinos





&lt;h2 id="do_assem"&gt; void do_assem(ComMod&amp; com_mod, const int d, const Vector&lt;int&gt;&amp; eqN, const Array3&lt;double&gt;&amp; lK, const Array&lt;double&gt;&amp; lR) &lt;/h2&gt;

&lt;a href="<a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/lhsa.cpp">https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/lhsa.cpp</a>" &gt;lhsa.cpp  Modifies @icode com_mod.R com_mod.Val @endicode </h2>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
